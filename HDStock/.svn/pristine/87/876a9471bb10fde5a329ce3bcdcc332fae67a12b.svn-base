//
//  HDLiveInerViewController.m
//  HDStock
//
//  Created by hd-app01 on 16/11/11.
//  Copyright © 2016年 hd-app02. All rights reserved.
//

#import "HDLiveInerViewController.h"
#import "HDLivePersonInfoViewController.h"
#import "HDLivePersonInfoViewController.h"
#import "HDLiveBoxViewController.h"
#import "HDGuPingViewController.h"
#import "HDLiveChateViewController.h"
#import "HDLiveLivingViewController.h"
//#import "HDLiveGuPingTableViewCell.h"

#import "HDLiveMovieViewController.h"
#import "HDLIveJinNangViewController.h"


#import <AliyunPlayerSDK/AliyunPlayerSDK.h>
#import <MediaPlayer/MediaPlayer.h>
#import <AVFoundation/AVAudioSession.h>
#import "AppDelegate.h"


@interface HDLiveInerViewController ()<UITableViewDelegate,UIPageViewControllerDelegate>{
    CGFloat headerViewHeight;//透视图高度
    CGFloat selectionBarHeight;//直播，聊天选择栏高度
    UIImageView * headPicIMV;//头像
    UILabel * nickNameLab;//昵称
    UILabel * liveStatusLab;//直播状态
    UILabel * profileLab;//资格证书
    UIButton * personInfoBtn;//个人信息按钮
    UIView * moveLineView;//可移动横线
    UIView * _headBgView;//顶部个人信息背景视图
    NSArray * selectionArr;//直播，聊天标题数组
    CGFloat selectionBtnWidht;//直播，聊天按钮宽度
    CGFloat verLineViewWidth;//直播，聊天之间的竖线宽度
    CGFloat moveLineViewWidth;//可移动横线宽度
    CGFloat moveLineViewHeight;//可移动横线高度
    UIView * selectionBgView;
    UIScrollView * contentScrollView;//装子控制器的view
    NSMutableArray * childVCArr;//子控制器数组
    NSArray * vcArr;//装子控制器
    UIViewController * _currentVC;//当前显示的控制器
    CGFloat zanBgViewHeight;//赞的背景视图高度
    //自定义导航条
    UIButton * navNickNameBtn;//导航条上的昵称labl
    UIImageView * navPlayerHeadPicIMV;//导航条上的直播者头像
    UIView * navCustomView;//导航条自定义背景视图
    CGFloat navHeadPicHeight;//头像高度
    CGFloat navNickNameWidth;//导航条上昵称labl高度
    CGFloat navCustomViewWidth;//导航条自定义背景视图宽度
    //直播
    NSURL*  mSourceURL;//直播网址
    BOOL replay;
    BOOL bSeeking;
    Reachability *conn;
    BOOL mPaused;
    
    UIButton * rotateBtn;//旋转按钮
    UIButton * closeVoiceBtn;//静音按钮
    CGFloat rotateBtnWidth;//旋转按钮宽度
    
    AppDelegate * _appDelegate;//用于控制本页面旋转
    BOOL isReconnectToVedioUrlBool;//是否重连直播地址：默认不重连
    
    
}
@property (nonatomic,strong) NSMutableArray * arr;

@property (nonatomic, strong) AliVcMediaPlayer* mPlayer;
@property (nonatomic, strong) UIView *mPlayerView;
@property (nonatomic, strong) Reachability *conn;
@property (nonatomic,assign)NSTimeInterval currentPlayPos;
@property (nonatomic,assign)CGPoint originalLocation;

@end

@implementation HDLiveInerViewController
@synthesize mPlayer;
@synthesize mPlayerView;
@synthesize conn;

- (void)viewWillDisappear:(BOOL)animated {
    [super viewWillDisappear:animated];
    _appDelegate.allowRotation = 0;
    [UIView animateWithDuration:0.3 animations:^{
        navCustomView.alpha = 0;
    }];
}
- (void) viewWillAppear:(BOOL)animated {
    [super viewWillAppear:animated];
    
    [UIView animateWithDuration:0.4 animations:^{
        navCustomView.alpha = 1;
    }];

}
- (void)viewDidLoad {
    [super viewDidLoad];
    
    [self setUp];
    [self setNav];
    [self setUpLive];//直播初始化
    [self setNormalBackNav];
    [self createHeaderView];
    [self createChildVCs];
    
}
- (void) setNav {
    //添加Logo,只在第一个页面显示，用下面这个方法
    navCustomView = [[UIView alloc] init];
    navCustomView.frame = CGRM(SCREEN_SIZE_WIDTH/4.0, STATUS_HEIGHT, navCustomViewWidth, NAV_HEIGHT);
//    navCustomView.backgroundColor = COLOR(redColor);
    
    //播主昵称标签
    NSString * playerName = @"胜者为王";
    CGSize navNameSize = [playerName sizeWithAttributes:@{NSFontAttributeName:[UIFont boldSystemFontOfSize:16]}];
    UIImage * navIntoImage = imageNamed(@"Live_into");
    navNickNameBtn = [ZHFactory createBtnWithFrame:CGRM(navCustomViewWidth-navNickNameWidth, CGHEIGHT(navCustomView.frame)/2.0-CGHEIGHT(navCustomView.frame)/2, navNickNameWidth, CGHEIGHT(navCustomView.frame)) title:playerName titleFont:[UIFont boldSystemFontOfSize:16] titleCoclor:[UIColor whiteColor] bgColor:nil cornerRadius:0];
    navNickNameBtn.titleLabel.textAlignment = NSTextAlignmentLeft;
    [navNickNameBtn setImage:navIntoImage forState:(UIControlStateNormal)];
    [navNickNameBtn setTitleEdgeInsets:UIEdgeInsetsMake(0, -navIntoImage.size.width, 0, navIntoImage.size.width)];
    [navNickNameBtn setImageEdgeInsets:UIEdgeInsetsMake(0, navNameSize.width, 0, -navNameSize.width-3)];
    [navNickNameBtn addTarget:self action:@selector(navNickNameBtnClicked:) forControlEvents:(UIControlEventTouchUpInside)];
    [navCustomView addSubview:navNickNameBtn];
    //头像
    navPlayerHeadPicIMV = [[UIImageView alloc] initWithFrame:CGRM(CGMIN_X(navNickNameBtn.frame)-navHeadPicHeight, CGMID_Y(navCustomView.frame)/2-navHeadPicHeight/2, navHeadPicHeight, navHeadPicHeight)];
    navPlayerHeadPicIMV.image = imageNamed(@"weidenglu");
    navPlayerHeadPicIMV.layer.cornerRadius = navHeadPicHeight/2;
    navPlayerHeadPicIMV.layer.masksToBounds = YES;
    [navCustomView addSubview:navPlayerHeadPicIMV];

    self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithCustomView:navCustomView];
    //用下面这个方法，则会把Logo添加到后面的每一个页面，不符合我的需求
    [self.navigationController.view addSubview:navCustomView];
    
    
}

- (void) backItemWithCustemViewBtnClicked {
    
    if(mPlayer != nil)
        [mPlayer destroy];
    
    [self removePlayerObserver];
    
    mPlayer = nil;
    mSourceURL = nil;
    [self switchToPortrait];
    [self.navigationController popViewControllerAnimated:YES];
}

- (void) setUp {
    //导航条
    navCustomViewWidth = SCREEN_SIZE_WIDTH/2.0;
    navHeadPicHeight = 32;
    navNickNameWidth = navCustomViewWidth*3/5;
    
    vcArr = @[[HDLiveLivingViewController new],[HDLiveChateViewController new],[HDGuPingViewController new],[HDLiveMovieViewController new],[HDLIveJinNangViewController new],[HDLiveBoxViewController new]];
    
    selectionArr = @[@"直播",@"聊天",@"股评",@"视屏",@"锦囊",@"百宝箱"];
    headerViewHeight = 120.0f;
    selectionBarHeight = 40.0f;//直播按钮所在行高度
    zanBgViewHeight = 50;//赞所在行的高度
    verLineViewWidth = 0.5;//竖线宽度
    selectionBtnWidht = (SCREEN_WIDTH-(selectionArr.count-1)*verLineViewWidth)/selectionArr.count;//直播按钮宽度
    moveLineViewWidth = selectionBtnWidht*7.0/9-2;//可移动的横线宽度
    moveLineViewHeight = 2;
    rotateBtnWidth = 34;//旋转按钮宽度
    //本控制器支持旋转
    _appDelegate = (AppDelegate *)[UIApplication sharedApplication].delegate;
    _appDelegate.allowRotation = 1;
    
}
//直播
- (void) SetMoiveSource:(NSURL*)url
{
    mSourceURL = [url copy];
}

- (void) setUpLive {
    // 阻止锁屏
    //进入照相界面，再退出照相。  阻止锁屏功能无效了:解决：放在-(void)viewWillAppear:(BOOL)animated里面
    [[UIApplication sharedApplication] setIdleTimerDisabled: YES];
    
    self.view.backgroundColor = [UIColor whiteColor];

    mPaused = false;
    
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(becomeActive)
                                                 name:UIApplicationDidBecomeActiveNotification
                                               object:nil];
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(resignActive)
                                                 name:UIApplicationWillResignActiveNotification
                                               object:nil];
    [self PlayMoive];
    
    mPlayer.scalingMode = scalingModeAspectFitWithCropping;
    
    [self addNetWorkCheckNotification];
}
- (void) addNetWorkCheckNotification {
    //add network notification
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(networkStateChange) name:kReachabilityChangedNotification object:nil];
    self.conn = [Reachability reachabilityForInternetConnection];
    [self.conn startNotifier];
}
- (void)networkStateChange
{
    //网络流判断网络状态
    if (mSourceURL && ![mSourceURL isFileURL]) {
        [self checkNetworkState];
    }
}

- (void)checkNetworkState
{
    // 1.检测wifi状态
    Reachability *wifi = [Reachability reachabilityForLocalWiFi];
    
    // 2.检测手机是否能上网络(WIFI\3G\2.5G)
    Reachability *conn = [Reachability reachabilityForInternetConnection];
    
    // 3.判断网络状态
    if ([wifi currentReachabilityStatus] != NotReachable) { // 有wifi
        NSLog(@"有wifi");
        if (isReconnectToVedioUrlBool) {//重连视屏地址url
            [self reconnectToVedioUrl];
        }else {
            [mPlayer play];
        }
    } else if ([conn currentReachabilityStatus] != NotReachable) { // 没有使用wifi, 使用手机自带网络进行上网
        NSLog(@"使用手机自带网络进行上网");
//        [MBProgressHUD showMessage:@"当前使用的是手机自带网络" ToView:self.view RemainTime:3];
        UIAlertView *alter = [[UIAlertView alloc] initWithTitle:@"" message:@"你当前使用的是手机自带网络" delegate:nil cancelButtonTitle:@"OK" otherButtonTitles:nil];
        [alter show];
        if (isReconnectToVedioUrlBool) {//重连视屏地址url
            [self reconnectToVedioUrl];
        }else {
            [mPlayer play];
        }
    } else { // 没有网络
        NSLog(@"没有网络");
        [MBProgressHUD hideHUDForView:mPlayerView];
        [MBProgressHUD showMessage:@"没有网络" ToView:self.view RemainTime:3];
        UIAlertView *alter = [[UIAlertView alloc] initWithTitle:@"" message:@"你的网络已断开，请到设置中去设置" delegate:nil cancelButtonTitle:@"OK" otherButtonTitles:nil];
        
        [alter show];
        [mPlayer pause];
    }
}

- (void)becomeActive{
    [self EnterForeGroundPlayVideo];
}

- (void)resignActive{
    [self EnterBackGroundPauseVideo];
}

-(void) EnterBackGroundPauseVideo
{
    if(mPlayer && mPaused == NO) {
        [mPlayer pause];
    }
}

-(void) EnterForeGroundPlayVideo
{
    if(mPlayer && mPaused == NO) {
        [mPlayer play];
    }
    
}
- (void) PlayMoive
{
    if(mSourceURL == nil)
        return;
    
    //new the player
    mPlayer = [[AliVcMediaPlayer alloc] init];
    
    //add player controls
    [self setupControls];
    
    //create player, and  set the show view
    [mPlayer create:mPlayerView];
    
    //register notifications
    [self addPlayerObserver];
    
    mPlayer.mediaType = MediaType_AUTO;
    mPlayer.timeout = 25000;
    mPlayer.dropBufferDuration = 8000;
    
    
    replay = NO;
    bSeeking = NO;
    
    //prepare and play the video
    AliVcMovieErrorCode err = [mPlayer prepareToPlay:mSourceURL];
    if(err != ALIVC_SUCCESS) {
        NSLog(@"preprare failed,error code is %d",(int)err);
        return;
    }
    
    err = [mPlayer play];
    if(err != ALIVC_SUCCESS) {
        NSLog(@"play failed,error code is %d",(int)err);
        return;
    }
    [MBProgressHUD showHUDAddedTo:mPlayerView animated:YES];
    //    [self showLoadingIndicators];
}
- (void) setupControls
{
    //视频显示区域
    mPlayerView = [[UIView alloc] init];
    mPlayerView.backgroundColor = [UIColor clearColor];
    [self.view addSubview:mPlayerView];
    
    //旋转按钮
    rotateBtn = [UIButton buttonWithType:(UIButtonTypeCustom)];
    rotateBtn.backgroundColor = UICOLOR(174, 128, 61, 1);
    rotateBtn.layer.cornerRadius = rotateBtnWidth/2;
    rotateBtn.layer.masksToBounds = YES;
    rotateBtn.alpha = 0.6;
    [rotateBtn setImage:imageNamed(@"Live_rotateToFullScreen") forState:(UIControlStateNormal)];
    [rotateBtn addTarget:self action:@selector(rotateBtnClicked:) forControlEvents:(UIControlEventTouchUpInside)];
    [self.view addSubview:rotateBtn];
    
    closeVoiceBtn = [UIButton buttonWithType:(UIButtonTypeCustom)];
    closeVoiceBtn.backgroundColor = UICOLOR(174, 128, 61, 1);
    closeVoiceBtn.layer.cornerRadius = rotateBtnWidth/2;
    closeVoiceBtn.layer.masksToBounds = YES;
    closeVoiceBtn.alpha = 0.6;
    [closeVoiceBtn setImage:imageNamed(@"Live_volume") forState:(UIControlStateNormal)];
    [closeVoiceBtn addTarget:self action:@selector(closeVoiceBtnClicked:) forControlEvents:(UIControlEventTouchUpInside)];
    [self.view addSubview:closeVoiceBtn];
    
    [self adjustLayoutsubViews];
}

- (float)iOSVersion {
    static float version = 0.f;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        version = [[[UIDevice currentDevice] systemVersion] floatValue];
    });
    return version;
}

- (void)adjustLayoutsubViews {
    
    UIDeviceOrientation orientation = [[UIDevice currentDevice]orientation];
    CGFloat width = [UIScreen mainScreen].bounds.size.width;
    CGFloat height = [UIScreen mainScreen].bounds.size.height;
    orientation = [[UIApplication sharedApplication] statusBarOrientation];
    float iosVersion = [self iOSVersion];
    if(iosVersion < 8.0) {
        if(UIDeviceOrientationIsLandscape(orientation) || orientation == UIDeviceOrientationUnknown ||
           orientation == UIDeviceOrientationFaceUp || orientation == UIDeviceOrientationFaceDown) {
            //landscape assume  width > height
            if(width<height) {
                CGFloat temp = width;
                width = height;
                height = temp;
            }
        }
    }
    
    mPlayerView.frame = CGRectMake(0,NAV_STATUS_HEIGHT,width,width*9.0/16);
    
    //when change the view size, need to reset the view to the play.
    mPlayer.view = mPlayerView;
    
    CGFloat space = 12;
    rotateBtn.frame = CGRM(CGMAX_X(mPlayerView.frame)-space-rotateBtnWidth, CGMAX_Y(mPlayerView.frame)-space-rotateBtnWidth, rotateBtnWidth, rotateBtnWidth);
    closeVoiceBtn.frame = CGRM(CGMIN_X(rotateBtn.frame), CGMIN_Y(rotateBtn.frame)-space-rotateBtnWidth, rotateBtnWidth, rotateBtnWidth);
}


//recieve prepared notification
- (void)OnVideoPrepared:(NSNotification *)notification {
    
    //    [self hideLoadingIndicators];
    [MBProgressHUD hideHUDForView:mPlayerView];
}

//recieve error notification
- (void)OnVideoError:(NSNotification *)notification {
    replay = YES;
    //    [playBtn setSelected:YES];
//    [self showControls:nil];
    
    [MBProgressHUD hideHUDForView:mPlayerView];
    NSString* error_msg = @"未知错误";
    AliVcMovieErrorCode error_code = mPlayer.errorCode;
    
    switch (error_code) {
        case ALIVC_ERR_FUNCTION_DENIED:
            error_msg = @"未授权";
            break;
        case ALIVC_ERR_ILLEGALSTATUS:
            error_msg = @"非法的播放流程";
            break;
        case ALIVC_ERR_INVALID_INPUTFILE:
            error_msg = @"无法打开";
            //            [self hideLoadingIndicators];
            [MBProgressHUD hideHUDForView:mPlayerView animated:YES];
            break;
        case ALIVC_ERR_NO_INPUTFILE:
            error_msg = @"无输入文件";
            //            [self hideLoadingIndicators];
            [MBProgressHUD hideHUDForView:mPlayerView animated:YES];
            break;
        case ALIVC_ERR_NO_NETWORK:
            error_msg = @"网络连接失败";
            break;
        case ALIVC_ERR_NO_SUPPORT_CODEC:
            error_msg = @"不支持的视频编码格式";
            //            [self hideLoadingIndicators];
            [MBProgressHUD hideHUDForView:mPlayerView animated:YES];
            break;
        case ALIVC_ERR_NO_VIEW:
            error_msg = @"无显示窗口";
            //            [self hideLoadingIndicators];
            [MBProgressHUD hideHUDForView:mPlayerView animated:YES];
            break;
        case ALIVC_ERR_NO_MEMORY:
            error_msg = @"内存不足";
            break;
        case ALIVC_ERR_DOWNLOAD_TIMEOUT:
            error_msg = @"网络超时";
            NSLog(@"%ld",(long)error_code);
            break;
        case ALIVC_ERR_UNKOWN:
            error_msg = @"未知错误";
            break;
        default:
            break;
    }
    

    //NSLog(error_msg);
    //the error message is important when error_cdoe > 500
    
    
    if(error_code > 500 || error_code == ALIVC_ERR_FUNCTION_DENIED) {
        
        if (error_code == ALIVC_ERR_DOWNLOAD_TIMEOUT) {//连接超时
            [mPlayer pause];
            UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"错误提示"
                                                            message:error_msg
                                                           delegate:self
                                                  cancelButtonTitle:@"等待"
                                                  otherButtonTitles:@"重新连接",nil];
            [alert show];
        }else {//连接失败的提示
            [mPlayer reset];
            UIAlertView *alter = [[UIAlertView alloc] initWithTitle:[mSourceURL absoluteString] message:error_msg delegate:self cancelButtonTitle:@"OK" otherButtonTitles:nil];
            
            [alter show];
            return;
        }
    }
    
}

-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{
    
    if (buttonIndex == 0) {//等待
        [mPlayer play];
        if (alertView.numberOfButtons == 1) {//连接视屏地址失败
            isReconnectToVedioUrlBool = YES;//标记为需要重连：当重新检测到有网时重连
        }
    }
    //reconnect
    else if(buttonIndex == 1) {//点击重连按钮，重连视屏url
        [self reconnectToVedioUrl];
    }
}
- (void) reconnectToVedioUrl {
    [mPlayer stop];
    [MBProgressHUD showHUDAddedTo:mPlayerView animated:YES];
    replay = YES;
    [self replay];
    isReconnectToVedioUrlBool = NO;
}
-(void)replay
{
    [mPlayer prepareToPlay:mSourceURL];
    replay = NO;
    bSeeking = NO;
    [mPlayer play];
}

//recieve finish notification
- (void)OnVideoFinish:(NSNotification *)notification {
    replay = YES;
    
    UIAlertView *alter = [[UIAlertView alloc] initWithTitle:@"播放完成" message:@"播放完成" delegate:nil cancelButtonTitle:@"OK" otherButtonTitles:nil];
    
    [alter show];

}

//recieve start cache notification
- (void)OnStartCache:(NSNotification *)notification {
    //    [self showLoadingIndicators];
    [MBProgressHUD showHUDAddedTo:mPlayerView animated:YES];
}

//recieve end cache notification
- (void)OnEndCache:(NSNotification *)notification {
    //    [self hideLoadingIndicators];
    [MBProgressHUD hideHUDForView:mPlayerView];
}

-(void)addPlayerObserver
{
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(OnVideoPrepared:)
                                                 name:AliVcMediaPlayerLoadDidPreparedNotification object:mPlayer];
    
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(OnVideoError:)
                                                 name:AliVcMediaPlayerPlaybackErrorNotification object:mPlayer];
    
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(OnVideoFinish:)
                                                 name:AliVcMediaPlayerPlaybackDidFinishNotification object:mPlayer];

    
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(OnStartCache:)
                                                 name:AliVcMediaPlayerStartCachingNotification object:mPlayer];
    
    [[NSNotificationCenter defaultCenter] addObserver:self
                                             selector:@selector(OnEndCache:)
                                                 name:AliVcMediaPlayerEndCachingNotification object:mPlayer];
}

-(void)removePlayerObserver
{
    [[NSNotificationCenter defaultCenter] removeObserver:self
                                                    name:AliVcMediaPlayerLoadDidPreparedNotification object:mPlayer];
    
    [[NSNotificationCenter defaultCenter] removeObserver:self
                                                    name:AliVcMediaPlayerPlaybackErrorNotification object:mPlayer];
    
    [[NSNotificationCenter defaultCenter] removeObserver:self
                                                    name:AliVcMediaPlayerPlaybackDidFinishNotification object:mPlayer];
    
    [[NSNotificationCenter defaultCenter] removeObserver:self
                                                    name:AliVcMediaPlayerStartCachingNotification object:mPlayer];
    
    [[NSNotificationCenter defaultCenter] removeObserver:self
                                                    name:AliVcMediaPlayerEndCachingNotification object:mPlayer];
}


- (BOOL)shouldAutorotate
{
    return YES;
}
- (UIInterfaceOrientationMask)supportedInterfaceOrientations
{
    if (_appDelegate.allowRotation == 1) {
        return UIInterfaceOrientationMaskLandscape;
    } else {
        return UIInterfaceOrientationMaskPortrait;
    }
}

- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration{
    
    CGFloat width = [UIScreen mainScreen].bounds.size.width;
    CGFloat height = [UIScreen mainScreen].bounds.size.height;
    
    if (toInterfaceOrientation == UIInterfaceOrientationPortrait||toInterfaceOrientation ==UIDeviceOrientationPortraitUpsideDown){//竖屏
        
        if(width>height) {
            CGFloat temp = width;
            width = height;
            height = temp;
        }
        
        mPlayerView.frame = CGRectMake(0,NAV_STATUS_HEIGHT,width,width*9.0/16);
        
    }else if (toInterfaceOrientation == UIInterfaceOrientationLandscapeRight || toInterfaceOrientation == UIInterfaceOrientationLandscapeLeft) {//横屏
        
        mPlayerView.frame = CGRectMake(0, 0, SCREEN_SIZE_HEIGHT, SCREEN_SIZE_WIDTH);
    }
    
    CGRect selectionFrame = selectionBgView.frame;
    selectionFrame.origin.y = CGMAX_Y(mPlayerView.frame);
    selectionFrame.size.width = CGWIDTH(mPlayerView.frame);
    selectionBgView.frame = selectionFrame;
    
    CGFloat space = 12;
    rotateBtn.frame = CGRM(CGMAX_X(mPlayerView.frame)-space-rotateBtnWidth, CGMAX_Y(mPlayerView.frame)-space-rotateBtnWidth, rotateBtnWidth, rotateBtnWidth);
    closeVoiceBtn.frame = CGRM(CGMIN_X(rotateBtn.frame), CGMIN_Y(rotateBtn.frame)-space-rotateBtnWidth, rotateBtnWidth, rotateBtnWidth);

}
-(void) dealloc
{
    
    [self.conn stopNotifier];
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}
#pragma mark - 创建界面

- (void) createHeaderView {

    CGFloat lineViewHeight = 0.8;//横线高度
    
    selectionBgView = [[UIView alloc] initWithFrame:CGRM(0,CGRectGetMaxY(mPlayerView.frame), SCREEN_WIDTH, selectionBarHeight+zanBgViewHeight)];
    selectionBgView.userInteractionEnabled = YES;
    selectionBgView.backgroundColor = COLOR(whiteColor);
    selectionBgView.userInteractionEnabled = YES;
    [self.view addSubview:selectionBgView];
    
    UIView * bottomLineView = [[UIView alloc] initWithFrame:CGRM(0, CGHEIGHT(selectionBgView.frame)-lineViewHeight, SCREEN_WIDTH, lineViewHeight)];
    bottomLineView.backgroundColor = LINE_COLOR;
    [selectionBgView addSubview:bottomLineView];
    
    //赞／赏，问
    NSArray * titleArr = @[@"赞",@"赏",@"问"];
    NSArray * colorArr = @[UICOLOR(198, 40, 64, 1),UICOLOR(215, 150, 61, 1),UICOLOR(43, 166, 199, 1)];
    CGFloat zanBtnHeight = 32;
    CGFloat startX =  (SCREEN_SIZE_WIDTH-zanBtnHeight*titleArr.count)/(titleArr.count+1);
    for (int i = 0; i < titleArr.count; i++) {
        
        UIButton * tempBtn = [ZHFactory createBtnWithFrame:CGRM(startX+(zanBtnHeight+startX)*i, zanBgViewHeight/2-zanBtnHeight/2, zanBtnHeight, zanBtnHeight) title:titleArr[i] titleFont:[UIFont boldSystemFontOfSize:22] titleCoclor:[UIColor whiteColor] bgColor:colorArr[i] cornerRadius:zanBtnHeight/2];
        [tempBtn addTarget:self action:@selector(zanBtnClicked:) forControlEvents:(UIControlEventTouchUpInside)];
        tempBtn.tag = 800+i;
        [selectionBgView addSubview:tempBtn];
        if (i == 0) {//赞
            tempBtn.frame = CGRM(startX-20*WIDTH, zanBgViewHeight/2-zanBtnHeight/2, zanBtnHeight, zanBtnHeight);
            
            UILabel * zanNumLabl = [ZHFactory createLabelWithFrame:CGRM(CGMAX_X(tempBtn.frame)+5, CGMIN_Y(tempBtn.frame), startX, CGHEIGHT(tempBtn.frame)) andFont:[UIFont boldSystemFontOfSize:17*WIDTH] andTitleColor:colorArr[i] title:@"0"];
            zanNumLabl.textAlignment = NSTextAlignmentLeft;
            [selectionBgView addSubview:zanNumLabl];
        }
    }
    
    //直播／聊天／百宝箱
    CGSize selectionSize = [@"直播" sizeWithAttributes:@{NSFontAttributeName:[UIFont systemFontOfSize:15]}];
    for (int i = 0; i < selectionArr.count; i++) {
        //按钮
        UIButton * tempBtn = [ZHFactory createBtnWithFrame:CGRM((selectionBtnWidht+verLineViewWidth)*i, zanBgViewHeight, selectionBtnWidht, selectionBarHeight-moveLineViewHeight) title:selectionArr[i] titleFont:(i == 0 ? boldSystemFont(15):[UIFont systemFontOfSize:15]) titleCoclor:TEXT_COLOR bgColor:[UIColor whiteColor] cornerRadius:0.1];
        [tempBtn setTitleColor:[UIColor blackColor] forState:(UIControlStateSelected)];
        tempBtn.tag = 500+i;
        i == 0 ? (tempBtn.selected = YES):(tempBtn.selected = NO);
        [tempBtn addTarget:self action:@selector(tempBtnClicked:) forControlEvents:UIControlEventTouchUpInside];
        [selectionBgView addSubview:tempBtn];

        //竖线
        if (i < selectionArr.count-1) {
            UIView * tempVerLineView = [[UIView alloc] initWithFrame:CGRM(CGRectGetMaxX(tempBtn.frame),CGMID_Y(tempBtn.frame)-selectionSize.height/2, verLineViewWidth, selectionSize.height)];
            tempVerLineView.backgroundColor = LINE_COLOR;
            [selectionBgView addSubview:tempVerLineView];
        }
        
        //移动的先线
        if (tempBtn.selected) {
            moveLineView = [UIView new];
            moveLineView.center = CGPointMake(CGRectGetMidX(tempBtn.frame), CGRectGetMaxY(tempBtn.frame)+1);
            moveLineView.bounds = CGRM(0, 0, moveLineViewWidth, moveLineViewHeight);
            moveLineView.backgroundColor = UICOLOR(0, 120, 205, 1);
            [selectionBgView addSubview:moveLineView];
        }
        
        if (i == 0) {
            //中间的横线
            UIView * centerLineView = [[UIView alloc] initWithFrame:CGRM(0, CGMIN_Y(tempBtn.frame)-2, SCREEN_WIDTH, lineViewHeight)];
            centerLineView.backgroundColor = LINE_COLOR;
            [selectionBgView addSubview:centerLineView];
        }
    }
}

#pragma mark - 创建子控制器
- (void) createChildVCs {
    for (int i = 0; i < vcArr.count; i++) {
        
        [self addChildViewController:vcArr[i]];
        [[vcArr[i] view] setTag:600+i];
    }
    _currentVC = vcArr[0];
    [self transitionFromOldViewController:_currentVC toNewViewController:vcArr[0]];
    [self fitFrameForChildViewController:vcArr[0]];
}

- (void)fitFrameForChildViewController:(UIViewController *)chileViewController{
    
    UIView *subView = _currentVC.view;
    CGRect subViewFrame = _currentVC.view.frame;
    subViewFrame.origin.y = CGRectGetMaxY(selectionBgView.frame)+1;
    subViewFrame.size.height = SCREEN_HEIGHT-CGRectGetMaxY(selectionBgView.frame)-1;
    subView.frame = subViewFrame;
}
#pragma mark - 点击事件
//导航条上个人信息按钮点击事件
- (void) navNickNameBtnClicked:(UIButton *)sender {
    HDLivePersonInfoViewController * vc = [HDLivePersonInfoViewController new];
    [self.navigationController pushViewController:vc animated:YES];
}

//屏幕旋转点击事件
- (void) rotateBtnClicked:(UIButton*)sender {
    sender.selected = !sender.selected;
    //手动切换横竖屏
    sender.selected?[self switchToLandscape]:[self switchToPortrait];
    
}
//点击按钮旋转到横屏
- (void)switchToLandscape
{
//    [[UIDevice currentDevice] setValue:[NSNumber numberWithInteger:UIInterfaceOrientationPortrait] forKey:@"orientation"];
    //上一句话是防止手动先把设备置为横屏,导致下面的语句失效.
    [[UIDevice currentDevice] setValue:[NSNumber numberWithInteger:UIDeviceOrientationLandscapeRight] forKey:@"orientation"];
}

//点击返回旋转到竖屏
- (void)switchToPortrait
{
//    [[UIDevice currentDevice] setValue:[NSNumber numberWithInteger:UIDeviceOrientationLandscapeLeft] forKey:@"orientation"];
    //上一句话是防止手动先把设备置为竖屏,导致下面的语句失效.
    [[UIDevice currentDevice] setValue:[NSNumber numberWithInteger:UIDeviceOrientationPortrait] forKey:@"orientation"];
}
//静音点击事件
- (void) closeVoiceBtnClicked:(UIButton*)sender {
    sender.selected = !sender.selected;

}
- (void) zanBtnClicked:(UIButton *)sender {
    NSLog(@"点赞");
}

//视屏，直播点击事件
- (void) tempBtnClicked:(UIButton *)sender {//500+
    for (UIView * tempView in selectionBgView.subviews) {
        if ([tempView isKindOfClass:[UIButton class]] && tempView.tag>=500&&tempView.tag<600) {
            UIButton * tempBtn = (UIButton*)tempView;
            tempBtn.selected = NO;
            tempBtn.titleLabel.font = systemFont(15);
        }
    }
    
    sender.selected = YES;
    sender.titleLabel.font = boldSystemFont(15);
    [UIView animateWithDuration:0.3 animations:^{
        moveLineView.center = CGPointMake(CGRectGetMidX(sender.frame), CGRectGetMaxY(sender.frame)+1);
        moveLineView.bounds = CGRM(0, 0, moveLineViewWidth, moveLineViewHeight);
    }];
    
    if ((sender.tag == 500 && _currentVC == vcArr[0]) || (sender.tag == 501 && _currentVC == vcArr[1]) || (sender.tag == 502 && _currentVC == vcArr[2]) || (sender.tag == 503 && _currentVC == vcArr[3])|| (sender.tag == 504 && _currentVC == vcArr[4])|| (sender.tag == 505 && _currentVC == vcArr[5])) {
        return;
    }
    _currentVC = vcArr[sender.tag-500];
    switch (sender.tag) {
        case 500:{//直播
            [self transitionFromOldViewController:_currentVC toNewViewController:vcArr[0]];
        }
            break;
        case 501:{//聊天
            [self transitionFromOldViewController:_currentVC toNewViewController:vcArr[1]];
        }
            break;
        case 502:{//股评
            [self transitionFromOldViewController:_currentVC toNewViewController:vcArr[2]];
        }
            break;
        case 503:{//视屏
            [self transitionFromOldViewController:_currentVC toNewViewController:vcArr[3]];
        }
            break;
        case 504:{//锦囊
            [self transitionFromOldViewController:_currentVC toNewViewController:vcArr[4]];
        }
            break;
        case 505:{//百宝箱
            [self transitionFromOldViewController:_currentVC toNewViewController:vcArr[5]];
        }
    }
    [self fitFrameForChildViewController:_currentVC];
}

//转换子视图控制器
- (void)transitionFromOldViewController:(UIViewController *)oldViewController toNewViewController:(UIViewController *)newViewController{
    [self transitionFromViewController:oldViewController toViewController:newViewController duration:0 options:UIViewAnimationOptionTransitionCrossDissolve animations:nil completion:^(BOOL finished) {
        if (finished) {
            [newViewController didMoveToParentViewController:self];
            _currentVC = newViewController;
        }else{
            _currentVC = oldViewController;
        }
        [self.view addSubview:_currentVC.view];
    }];
}

//个人信息点击事件
- (void) headBtnClicked:(UIButton *)sender {
    
    HDLivePersonInfoViewController * vc = [[HDLivePersonInfoViewController alloc] init];
    [self.navigationController pushViewController:vc animated:YES];
    
}
@end
